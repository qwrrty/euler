#! /usr/bin/env python

# https://projecteuler.net/problem=59
#
# The message in p059_cipher.txt is an English text that has been
# XOR-encrypted using a key that consists of three lowercase characters
# and repeated throughout the message.  Determine the key, decrypt
# the message, and print the sum of the ASCII values in the text.
#
# ====================
#
# Strategy:
#
# Brute-force decryption is a necessary component here. The challenge
# is how to tell whether 

import csv
import re
import time

import numpy

def read_csv(csvfile):
    """Reads CSV data from an input file and returns a single list
    containing all of the fields.

    Raises ValueError if the input file contains any non-numeric fields.
    """
    data = []
    with open(csvfile, 'r') as f:
        csvreader = csv.reader(f)
        for row in csvreader:
            data += [ int(x) for x in row ]
    return data

def read_dictionary(dictfile='/usr/share/dict/words'):
    """Reads the contents of the specified dictionary.
    Returns a set of all the dictionary entries found.
    """
    d = set()
    with open(dictfile, 'r') as f:
        for word in f:
            d.add(word.strip())
    return d

def key_generator():
    """Generates all possible three-character lowercase keys.

    Returns a string containing the key on each call to the generator."""
    for a in range(ord('a'), ord('z')+1):
        for b in range(ord('a'), ord('z')+1):
            for c in range(ord('a'), ord('z')+1):
                yield chr(a) + chr(b) + chr(c)

def xor(msg, key):
    """Repeatedly XORs a message with a key.

    message: a list of integer ASCII values
    key: a string of ASCII chars

    Returns a string consisting of each character generated by
    successively XORing elements of the message with the key.
    """
    msglen = len(msg)

    # numpy.bitwise_xor requires the operands to be the same length.
    # If the message is longer than the key, repeat the key until
    # it is long enough.
    # If the key is longer than the message, truncate it.
    xorkey = key
    if msglen > len(key):
        xorkey = key * (msglen / len(key) + 1)
    xorkey = xorkey[:msglen]

    # Pad out the message and the key to a multiple of 8,
    # so we can xor 8 bytes at once.
    data = msg
    if msglen % 8 != 0:
        padding = 8 - msglen % 8
        data = msg + [0] * padding
        xorkey += ''.join([chr(0)] * padding)

    plaintext = numpy.bitwise_xor(
        numpy.frombuffer(bytearray(data), dtype=numpy.dtype('<Q8')),
        numpy.fromstring(xorkey, dtype=numpy.dtype('<Q8'))).tostring()

    return plaintext[:msglen]

def decipher(message):
    dictionary = read_dictionary()
    for key in key_generator():
        cleartext = xor(message, key)

        # The text is expected to consist principally of English
        # words; however, it is not guaranteed that every word in the
        # text is English or that it will be found in the dictionary
        # we have.  Report success if, of the cleartext words that are
        # five letters or longer, at least half are found in the dictionary.
        words = re.findall(r'[A-Za-z]+', cleartext) 
        longwords = [ w for w in words if len(w) >= 5 ]
        englishwords = [ w for w in longwords if w in dictionary ]
        if len(englishwords) >= len(longwords) / 2:
            return cleartext

if __name__ == '__main__':
    t1 = time.clock()
    msg = read_csv('p059_cipher.txt')
    s = decipher(msg)
    msgsum = sum([ ord(ch) for ch in s ])
    t2 = time.clock()
    print msgsum
    print t2 - t1

